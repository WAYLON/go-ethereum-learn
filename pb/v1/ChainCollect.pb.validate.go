// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: v1/pbfile/ChainCollect.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ParseDataReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ParseDataReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParseDataReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ParseDataReqMultiError, or
// nil if none found.
func (m *ParseDataReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ParseDataReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Topic0

	// no validation rules for Topic1

	// no validation rules for Topic2

	// no validation rules for Topic3

	// no validation rules for Data

	if len(errors) > 0 {
		return ParseDataReqMultiError(errors)
	}

	return nil
}

// ParseDataReqMultiError is an error wrapping multiple validation errors
// returned by ParseDataReq.ValidateAll() if the designated constraints aren't met.
type ParseDataReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParseDataReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParseDataReqMultiError) AllErrors() []error { return m }

// ParseDataReqValidationError is the validation error returned by
// ParseDataReq.Validate if the designated constraints aren't met.
type ParseDataReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParseDataReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParseDataReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParseDataReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParseDataReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParseDataReqValidationError) ErrorName() string { return "ParseDataReqValidationError" }

// Error satisfies the builtin error interface
func (e ParseDataReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParseDataReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParseDataReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParseDataReqValidationError{}

// Validate checks the field values on ParseDataResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ParseDataResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParseDataResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ParseDataRespMultiError, or
// nil if none found.
func (m *ParseDataResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ParseDataResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Value.(type) {
	case *ParseDataResp_ABIFunctionDetail:
		if v == nil {
			err := ParseDataRespValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetABIFunctionDetail()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParseDataRespValidationError{
						field:  "ABIFunctionDetail",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParseDataRespValidationError{
						field:  "ABIFunctionDetail",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetABIFunctionDetail()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParseDataRespValidationError{
					field:  "ABIFunctionDetail",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ParseDataResp_ABIEventDetail:
		if v == nil {
			err := ParseDataRespValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetABIEventDetail()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParseDataRespValidationError{
						field:  "ABIEventDetail",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParseDataRespValidationError{
						field:  "ABIEventDetail",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetABIEventDetail()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParseDataRespValidationError{
					field:  "ABIEventDetail",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ParseDataResp_ABIErrorDetail:
		if v == nil {
			err := ParseDataRespValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetABIErrorDetail()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParseDataRespValidationError{
						field:  "ABIErrorDetail",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParseDataRespValidationError{
						field:  "ABIErrorDetail",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetABIErrorDetail()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParseDataRespValidationError{
					field:  "ABIErrorDetail",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ParseDataRespMultiError(errors)
	}

	return nil
}

// ParseDataRespMultiError is an error wrapping multiple validation errors
// returned by ParseDataResp.ValidateAll() if the designated constraints
// aren't met.
type ParseDataRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParseDataRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParseDataRespMultiError) AllErrors() []error { return m }

// ParseDataRespValidationError is the validation error returned by
// ParseDataResp.Validate if the designated constraints aren't met.
type ParseDataRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParseDataRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParseDataRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParseDataRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParseDataRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParseDataRespValidationError) ErrorName() string { return "ParseDataRespValidationError" }

// Error satisfies the builtin error interface
func (e ParseDataRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParseDataResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParseDataRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParseDataRespValidationError{}

// Validate checks the field values on StorageAbiReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StorageAbiReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StorageAbiReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StorageAbiReqMultiError, or
// nil if none found.
func (m *StorageAbiReq) ValidateAll() error {
	return m.validate(true)
}

func (m *StorageAbiReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Content

	if len(errors) > 0 {
		return StorageAbiReqMultiError(errors)
	}

	return nil
}

// StorageAbiReqMultiError is an error wrapping multiple validation errors
// returned by StorageAbiReq.ValidateAll() if the designated constraints
// aren't met.
type StorageAbiReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StorageAbiReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StorageAbiReqMultiError) AllErrors() []error { return m }

// StorageAbiReqValidationError is the validation error returned by
// StorageAbiReq.Validate if the designated constraints aren't met.
type StorageAbiReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StorageAbiReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StorageAbiReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StorageAbiReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StorageAbiReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StorageAbiReqValidationError) ErrorName() string { return "StorageAbiReqValidationError" }

// Error satisfies the builtin error interface
func (e StorageAbiReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStorageAbiReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StorageAbiReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StorageAbiReqValidationError{}

// Validate checks the field values on FilterSetReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FilterSetReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FilterSetReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FilterSetReqMultiError, or
// nil if none found.
func (m *FilterSetReq) ValidateAll() error {
	return m.validate(true)
}

func (m *FilterSetReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if len(errors) > 0 {
		return FilterSetReqMultiError(errors)
	}

	return nil
}

// FilterSetReqMultiError is an error wrapping multiple validation errors
// returned by FilterSetReq.ValidateAll() if the designated constraints aren't met.
type FilterSetReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FilterSetReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FilterSetReqMultiError) AllErrors() []error { return m }

// FilterSetReqValidationError is the validation error returned by
// FilterSetReq.Validate if the designated constraints aren't met.
type FilterSetReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FilterSetReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FilterSetReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FilterSetReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FilterSetReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FilterSetReqValidationError) ErrorName() string { return "FilterSetReqValidationError" }

// Error satisfies the builtin error interface
func (e FilterSetReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFilterSetReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FilterSetReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FilterSetReqValidationError{}

// Validate checks the field values on FilterSetResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FilterSetResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FilterSetResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FilterSetRespMultiError, or
// nil if none found.
func (m *FilterSetResp) ValidateAll() error {
	return m.validate(true)
}

func (m *FilterSetResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for Update

	if len(errors) > 0 {
		return FilterSetRespMultiError(errors)
	}

	return nil
}

// FilterSetRespMultiError is an error wrapping multiple validation errors
// returned by FilterSetResp.ValidateAll() if the designated constraints
// aren't met.
type FilterSetRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FilterSetRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FilterSetRespMultiError) AllErrors() []error { return m }

// FilterSetRespValidationError is the validation error returned by
// FilterSetResp.Validate if the designated constraints aren't met.
type FilterSetRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FilterSetRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FilterSetRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FilterSetRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FilterSetRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FilterSetRespValidationError) ErrorName() string { return "FilterSetRespValidationError" }

// Error satisfies the builtin error interface
func (e FilterSetRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFilterSetResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FilterSetRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FilterSetRespValidationError{}

// Validate checks the field values on NoResp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NoResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NoResp with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in NoRespMultiError, or nil if none found.
func (m *NoResp) ValidateAll() error {
	return m.validate(true)
}

func (m *NoResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return NoRespMultiError(errors)
	}

	return nil
}

// NoRespMultiError is an error wrapping multiple validation errors returned by
// NoResp.ValidateAll() if the designated constraints aren't met.
type NoRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NoRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NoRespMultiError) AllErrors() []error { return m }

// NoRespValidationError is the validation error returned by NoResp.Validate if
// the designated constraints aren't met.
type NoRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NoRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NoRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NoRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NoRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NoRespValidationError) ErrorName() string { return "NoRespValidationError" }

// Error satisfies the builtin error interface
func (e NoRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNoResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NoRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NoRespValidationError{}

// Validate checks the field values on NoReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NoReq with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in NoReqMultiError, or nil if none found.
func (m *NoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *NoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return NoReqMultiError(errors)
	}

	return nil
}

// NoReqMultiError is an error wrapping multiple validation errors returned by
// NoReq.ValidateAll() if the designated constraints aren't met.
type NoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NoReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NoReqMultiError) AllErrors() []error { return m }

// NoReqValidationError is the validation error returned by NoReq.Validate if
// the designated constraints aren't met.
type NoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NoReqValidationError) ErrorName() string { return "NoReqValidationError" }

// Error satisfies the builtin error interface
func (e NoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NoReqValidationError{}

// Validate checks the field values on GetBlocksReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetBlocksReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBlocksReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetBlocksReqMultiError, or
// nil if none found.
func (m *GetBlocksReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBlocksReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPageInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBlocksReqValidationError{
					field:  "PageInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBlocksReqValidationError{
					field:  "PageInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPageInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBlocksReqValidationError{
				field:  "PageInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for StartTime

	// no validation rules for EndTime

	// no validation rules for StartNumber

	// no validation rules for EndNumber

	// no validation rules for Miner

	// no validation rules for Status

	// no validation rules for ChainId

	if len(errors) > 0 {
		return GetBlocksReqMultiError(errors)
	}

	return nil
}

// GetBlocksReqMultiError is an error wrapping multiple validation errors
// returned by GetBlocksReq.ValidateAll() if the designated constraints aren't met.
type GetBlocksReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBlocksReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBlocksReqMultiError) AllErrors() []error { return m }

// GetBlocksReqValidationError is the validation error returned by
// GetBlocksReq.Validate if the designated constraints aren't met.
type GetBlocksReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBlocksReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBlocksReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBlocksReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBlocksReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBlocksReqValidationError) ErrorName() string { return "GetBlocksReqValidationError" }

// Error satisfies the builtin error interface
func (e GetBlocksReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBlocksReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBlocksReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBlocksReqValidationError{}

// Validate checks the field values on GetBlocksResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetBlocksResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBlocksResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetBlocksRespMultiError, or
// nil if none found.
func (m *GetBlocksResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBlocksResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBlocks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetBlocksRespValidationError{
						field:  fmt.Sprintf("Blocks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetBlocksRespValidationError{
						field:  fmt.Sprintf("Blocks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetBlocksRespValidationError{
					field:  fmt.Sprintf("Blocks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetBlocksRespMultiError(errors)
	}

	return nil
}

// GetBlocksRespMultiError is an error wrapping multiple validation errors
// returned by GetBlocksResp.ValidateAll() if the designated constraints
// aren't met.
type GetBlocksRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBlocksRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBlocksRespMultiError) AllErrors() []error { return m }

// GetBlocksRespValidationError is the validation error returned by
// GetBlocksResp.Validate if the designated constraints aren't met.
type GetBlocksRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBlocksRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBlocksRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBlocksRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBlocksRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBlocksRespValidationError) ErrorName() string { return "GetBlocksRespValidationError" }

// Error satisfies the builtin error interface
func (e GetBlocksRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBlocksResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBlocksRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBlocksRespValidationError{}

// Validate checks the field values on GetTransactionsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransactionsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTransactionsReqMultiError, or nil if none found.
func (m *GetTransactionsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPageInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTransactionsReqValidationError{
					field:  "PageInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTransactionsReqValidationError{
					field:  "PageInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPageInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTransactionsReqValidationError{
				field:  "PageInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for StartTime

	// no validation rules for EndTime

	// no validation rules for From

	// no validation rules for To

	// no validation rules for Status

	// no validation rules for Type

	// no validation rules for Nonce

	// no validation rules for Hash

	// no validation rules for BlockId

	// no validation rules for BlockHash

	// no validation rules for StartBlockNumber

	// no validation rules for EndBlockNumber

	// no validation rules for ChainId

	if len(errors) > 0 {
		return GetTransactionsReqMultiError(errors)
	}

	return nil
}

// GetTransactionsReqMultiError is an error wrapping multiple validation errors
// returned by GetTransactionsReq.ValidateAll() if the designated constraints
// aren't met.
type GetTransactionsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionsReqMultiError) AllErrors() []error { return m }

// GetTransactionsReqValidationError is the validation error returned by
// GetTransactionsReq.Validate if the designated constraints aren't met.
type GetTransactionsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionsReqValidationError) ErrorName() string {
	return "GetTransactionsReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionsReqValidationError{}

// Validate checks the field values on GetTransactionsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransactionsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTransactionsRespMultiError, or nil if none found.
func (m *GetTransactionsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTransactionsRespValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTransactionsRespValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTransactionsRespValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetTransactionsRespMultiError(errors)
	}

	return nil
}

// GetTransactionsRespMultiError is an error wrapping multiple validation
// errors returned by GetTransactionsResp.ValidateAll() if the designated
// constraints aren't met.
type GetTransactionsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionsRespMultiError) AllErrors() []error { return m }

// GetTransactionsRespValidationError is the validation error returned by
// GetTransactionsResp.Validate if the designated constraints aren't met.
type GetTransactionsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionsRespValidationError) ErrorName() string {
	return "GetTransactionsRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionsRespValidationError{}

// Validate checks the field values on GetEventsReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetEventsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetEventsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetEventsReqMultiError, or
// nil if none found.
func (m *GetEventsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetEventsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPageInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetEventsReqValidationError{
					field:  "PageInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetEventsReqValidationError{
					field:  "PageInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPageInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetEventsReqValidationError{
				field:  "PageInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for StartTime

	// no validation rules for EndTime

	// no validation rules for Type

	// no validation rules for Topic0

	// no validation rules for Topic1

	// no validation rules for Topic2

	// no validation rules for Topic3

	// no validation rules for Contract

	// no validation rules for TransactionId

	// no validation rules for TransactionHash

	// no validation rules for TransactionFrom

	// no validation rules for TransactionTo

	// no validation rules for BlockId

	// no validation rules for BlockHash

	// no validation rules for StartBlockNumber

	// no validation rules for EndBlockNumber

	// no validation rules for ChainId

	if len(errors) > 0 {
		return GetEventsReqMultiError(errors)
	}

	return nil
}

// GetEventsReqMultiError is an error wrapping multiple validation errors
// returned by GetEventsReq.ValidateAll() if the designated constraints aren't met.
type GetEventsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetEventsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetEventsReqMultiError) AllErrors() []error { return m }

// GetEventsReqValidationError is the validation error returned by
// GetEventsReq.Validate if the designated constraints aren't met.
type GetEventsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetEventsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetEventsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetEventsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetEventsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetEventsReqValidationError) ErrorName() string { return "GetEventsReqValidationError" }

// Error satisfies the builtin error interface
func (e GetEventsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetEventsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetEventsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetEventsReqValidationError{}

// Validate checks the field values on GetEventsResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetEventsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetEventsResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetEventsRespMultiError, or
// nil if none found.
func (m *GetEventsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetEventsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetEventsRespValidationError{
						field:  fmt.Sprintf("Events[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetEventsRespValidationError{
						field:  fmt.Sprintf("Events[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetEventsRespValidationError{
					field:  fmt.Sprintf("Events[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetEventsRespMultiError(errors)
	}

	return nil
}

// GetEventsRespMultiError is an error wrapping multiple validation errors
// returned by GetEventsResp.ValidateAll() if the designated constraints
// aren't met.
type GetEventsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetEventsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetEventsRespMultiError) AllErrors() []error { return m }

// GetEventsRespValidationError is the validation error returned by
// GetEventsResp.Validate if the designated constraints aren't met.
type GetEventsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetEventsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetEventsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetEventsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetEventsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetEventsRespValidationError) ErrorName() string { return "GetEventsRespValidationError" }

// Error satisfies the builtin error interface
func (e GetEventsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetEventsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetEventsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetEventsRespValidationError{}

// Validate checks the field values on BlockConfirmStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BlockConfirmStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlockConfirmStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BlockConfirmStatusMultiError, or nil if none found.
func (m *BlockConfirmStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *BlockConfirmStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ConfirmNumbers

	// no validation rules for SuggestConfirm

	if len(errors) > 0 {
		return BlockConfirmStatusMultiError(errors)
	}

	return nil
}

// BlockConfirmStatusMultiError is an error wrapping multiple validation errors
// returned by BlockConfirmStatus.ValidateAll() if the designated constraints
// aren't met.
type BlockConfirmStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlockConfirmStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlockConfirmStatusMultiError) AllErrors() []error { return m }

// BlockConfirmStatusValidationError is the validation error returned by
// BlockConfirmStatus.Validate if the designated constraints aren't met.
type BlockConfirmStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlockConfirmStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlockConfirmStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlockConfirmStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlockConfirmStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlockConfirmStatusValidationError) ErrorName() string {
	return "BlockConfirmStatusValidationError"
}

// Error satisfies the builtin error interface
func (e BlockConfirmStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlockConfirmStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlockConfirmStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlockConfirmStatusValidationError{}

// Validate checks the field values on BlockInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BlockInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlockInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BlockInfoMultiError, or nil
// if none found.
func (m *BlockInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *BlockInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Number

	// no validation rules for Hash

	// no validation rules for Status

	// no validation rules for Time

	// no validation rules for Miner

	// no validation rules for TransactionNum

	// no validation rules for EventNum

	// no validation rules for ChainId

	if all {
		switch v := interface{}(m.GetBlockConfirmStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockInfoValidationError{
					field:  "BlockConfirmStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockInfoValidationError{
					field:  "BlockConfirmStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBlockConfirmStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockInfoValidationError{
				field:  "BlockConfirmStatus",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BlockInfoMultiError(errors)
	}

	return nil
}

// BlockInfoMultiError is an error wrapping multiple validation errors returned
// by BlockInfo.ValidateAll() if the designated constraints aren't met.
type BlockInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlockInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlockInfoMultiError) AllErrors() []error { return m }

// BlockInfoValidationError is the validation error returned by
// BlockInfo.Validate if the designated constraints aren't met.
type BlockInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlockInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlockInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlockInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlockInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlockInfoValidationError) ErrorName() string { return "BlockInfoValidationError" }

// Error satisfies the builtin error interface
func (e BlockInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlockInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlockInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlockInfoValidationError{}

// Validate checks the field values on TransactionInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TransactionInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionInfoMultiError, or nil if none found.
func (m *TransactionInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Hash

	// no validation rules for From

	// no validation rules for To

	// no validation rules for Gas

	// no validation rules for GasPrice

	// no validation rules for Time

	// no validation rules for Status

	// no validation rules for Type

	// no validation rules for Nonce

	// no validation rules for Value

	// no validation rules for Data

	// no validation rules for BlockId

	// no validation rules for BlockHash

	// no validation rules for BlockNum

	// no validation rules for ChainId

	if all {
		switch v := interface{}(m.GetBlockConfirmStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionInfoValidationError{
					field:  "BlockConfirmStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionInfoValidationError{
					field:  "BlockConfirmStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBlockConfirmStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionInfoValidationError{
				field:  "BlockConfirmStatus",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAbiDetail()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionInfoValidationError{
					field:  "AbiDetail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionInfoValidationError{
					field:  "AbiDetail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAbiDetail()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionInfoValidationError{
				field:  "AbiDetail",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetRelationEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionInfoValidationError{
						field:  fmt.Sprintf("RelationEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionInfoValidationError{
						field:  fmt.Sprintf("RelationEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionInfoValidationError{
					field:  fmt.Sprintf("RelationEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetErrorAbiDetail()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionInfoValidationError{
					field:  "ErrorAbiDetail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionInfoValidationError{
					field:  "ErrorAbiDetail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetErrorAbiDetail()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionInfoValidationError{
				field:  "ErrorAbiDetail",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TransactionInfoMultiError(errors)
	}

	return nil
}

// TransactionInfoMultiError is an error wrapping multiple validation errors
// returned by TransactionInfo.ValidateAll() if the designated constraints
// aren't met.
type TransactionInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionInfoMultiError) AllErrors() []error { return m }

// TransactionInfoValidationError is the validation error returned by
// TransactionInfo.Validate if the designated constraints aren't met.
type TransactionInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionInfoValidationError) ErrorName() string { return "TransactionInfoValidationError" }

// Error satisfies the builtin error interface
func (e TransactionInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionInfoValidationError{}

// Validate checks the field values on EventInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EventInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EventInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EventInfoMultiError, or nil
// if none found.
func (m *EventInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *EventInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Type

	// no validation rules for Time

	// no validation rules for Topic0

	// no validation rules for Topic1

	// no validation rules for Topic2

	// no validation rules for Topic3

	// no validation rules for Index

	// no validation rules for Status

	// no validation rules for Contract

	// no validation rules for Data

	// no validation rules for BlockId

	// no validation rules for BlockHash

	// no validation rules for BlockNum

	// no validation rules for TransactionId

	// no validation rules for TransactionHash

	// no validation rules for TransactionFrom

	// no validation rules for TransactionTo

	// no validation rules for ChainId

	if all {
		switch v := interface{}(m.GetBlockConfirmStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EventInfoValidationError{
					field:  "BlockConfirmStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EventInfoValidationError{
					field:  "BlockConfirmStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBlockConfirmStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EventInfoValidationError{
				field:  "BlockConfirmStatus",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAbiDetail()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EventInfoValidationError{
					field:  "AbiDetail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EventInfoValidationError{
					field:  "AbiDetail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAbiDetail()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EventInfoValidationError{
				field:  "AbiDetail",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetRelationEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventInfoValidationError{
						field:  fmt.Sprintf("RelationEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventInfoValidationError{
						field:  fmt.Sprintf("RelationEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventInfoValidationError{
					field:  fmt.Sprintf("RelationEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRelationTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EventInfoValidationError{
					field:  "RelationTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EventInfoValidationError{
					field:  "RelationTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRelationTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EventInfoValidationError{
				field:  "RelationTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for LastBlockHash

	if len(errors) > 0 {
		return EventInfoMultiError(errors)
	}

	return nil
}

// EventInfoMultiError is an error wrapping multiple validation errors returned
// by EventInfo.ValidateAll() if the designated constraints aren't met.
type EventInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventInfoMultiError) AllErrors() []error { return m }

// EventInfoValidationError is the validation error returned by
// EventInfo.Validate if the designated constraints aren't met.
type EventInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventInfoValidationError) ErrorName() string { return "EventInfoValidationError" }

// Error satisfies the builtin error interface
func (e EventInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventInfoValidationError{}

// Validate checks the field values on ABIFunctionDetail with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ABIFunctionDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ABIFunctionDetail with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ABIFunctionDetailMultiError, or nil if none found.
func (m *ABIFunctionDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *ABIFunctionDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	for idx, item := range m.GetInputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ABIFunctionDetailValidationError{
						field:  fmt.Sprintf("Inputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ABIFunctionDetailValidationError{
						field:  fmt.Sprintf("Inputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ABIFunctionDetailValidationError{
					field:  fmt.Sprintf("Inputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ABIFunctionDetailValidationError{
						field:  fmt.Sprintf("Outputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ABIFunctionDetailValidationError{
						field:  fmt.Sprintf("Outputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ABIFunctionDetailValidationError{
					field:  fmt.Sprintf("Outputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ABIFunctionDetailMultiError(errors)
	}

	return nil
}

// ABIFunctionDetailMultiError is an error wrapping multiple validation errors
// returned by ABIFunctionDetail.ValidateAll() if the designated constraints
// aren't met.
type ABIFunctionDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ABIFunctionDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ABIFunctionDetailMultiError) AllErrors() []error { return m }

// ABIFunctionDetailValidationError is the validation error returned by
// ABIFunctionDetail.Validate if the designated constraints aren't met.
type ABIFunctionDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ABIFunctionDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ABIFunctionDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ABIFunctionDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ABIFunctionDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ABIFunctionDetailValidationError) ErrorName() string {
	return "ABIFunctionDetailValidationError"
}

// Error satisfies the builtin error interface
func (e ABIFunctionDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sABIFunctionDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ABIFunctionDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ABIFunctionDetailValidationError{}

// Validate checks the field values on ABIEventDetail with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ABIEventDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ABIEventDetail with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ABIEventDetailMultiError,
// or nil if none found.
func (m *ABIEventDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *ABIEventDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	for idx, item := range m.GetParams() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ABIEventDetailValidationError{
						field:  fmt.Sprintf("Params[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ABIEventDetailValidationError{
						field:  fmt.Sprintf("Params[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ABIEventDetailValidationError{
					field:  fmt.Sprintf("Params[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ABIEventDetailMultiError(errors)
	}

	return nil
}

// ABIEventDetailMultiError is an error wrapping multiple validation errors
// returned by ABIEventDetail.ValidateAll() if the designated constraints
// aren't met.
type ABIEventDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ABIEventDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ABIEventDetailMultiError) AllErrors() []error { return m }

// ABIEventDetailValidationError is the validation error returned by
// ABIEventDetail.Validate if the designated constraints aren't met.
type ABIEventDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ABIEventDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ABIEventDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ABIEventDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ABIEventDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ABIEventDetailValidationError) ErrorName() string { return "ABIEventDetailValidationError" }

// Error satisfies the builtin error interface
func (e ABIEventDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sABIEventDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ABIEventDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ABIEventDetailValidationError{}

// Validate checks the field values on ABIErrorDetail with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ABIErrorDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ABIErrorDetail with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ABIErrorDetailMultiError,
// or nil if none found.
func (m *ABIErrorDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *ABIErrorDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	for idx, item := range m.GetInputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ABIErrorDetailValidationError{
						field:  fmt.Sprintf("Inputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ABIErrorDetailValidationError{
						field:  fmt.Sprintf("Inputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ABIErrorDetailValidationError{
					field:  fmt.Sprintf("Inputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ABIErrorDetailMultiError(errors)
	}

	return nil
}

// ABIErrorDetailMultiError is an error wrapping multiple validation errors
// returned by ABIErrorDetail.ValidateAll() if the designated constraints
// aren't met.
type ABIErrorDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ABIErrorDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ABIErrorDetailMultiError) AllErrors() []error { return m }

// ABIErrorDetailValidationError is the validation error returned by
// ABIErrorDetail.Validate if the designated constraints aren't met.
type ABIErrorDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ABIErrorDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ABIErrorDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ABIErrorDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ABIErrorDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ABIErrorDetailValidationError) ErrorName() string { return "ABIErrorDetailValidationError" }

// Error satisfies the builtin error interface
func (e ABIErrorDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sABIErrorDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ABIErrorDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ABIErrorDetailValidationError{}

// Validate checks the field values on ABIParam with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ABIParam) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ABIParam with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ABIParamMultiError, or nil
// if none found.
func (m *ABIParam) ValidateAll() error {
	return m.validate(true)
}

func (m *ABIParam) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FieldName

	// no validation rules for TypeName

	switch v := m.Value.(type) {
	case *ABIParam_BaseValue:
		if v == nil {
			err := ABIParamValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBaseValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ABIParamValidationError{
						field:  "BaseValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ABIParamValidationError{
						field:  "BaseValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBaseValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ABIParamValidationError{
					field:  "BaseValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ABIParam_BaseValues:
		if v == nil {
			err := ABIParamValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBaseValues()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ABIParamValidationError{
						field:  "BaseValues",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ABIParamValidationError{
						field:  "BaseValues",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBaseValues()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ABIParamValidationError{
					field:  "BaseValues",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ABIParam_StructValue:
		if v == nil {
			err := ABIParamValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStructValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ABIParamValidationError{
						field:  "StructValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ABIParamValidationError{
						field:  "StructValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStructValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ABIParamValidationError{
					field:  "StructValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ABIParam_StructValues:
		if v == nil {
			err := ABIParamValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStructValues()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ABIParamValidationError{
						field:  "StructValues",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ABIParamValidationError{
						field:  "StructValues",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStructValues()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ABIParamValidationError{
					field:  "StructValues",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ABIParam_BytesDecodeValue:
		if v == nil {
			err := ABIParamValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBytesDecodeValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ABIParamValidationError{
						field:  "BytesDecodeValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ABIParamValidationError{
						field:  "BytesDecodeValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBytesDecodeValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ABIParamValidationError{
					field:  "BytesDecodeValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ABIParamMultiError(errors)
	}

	return nil
}

// ABIParamMultiError is an error wrapping multiple validation errors returned
// by ABIParam.ValidateAll() if the designated constraints aren't met.
type ABIParamMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ABIParamMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ABIParamMultiError) AllErrors() []error { return m }

// ABIParamValidationError is the validation error returned by
// ABIParam.Validate if the designated constraints aren't met.
type ABIParamValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ABIParamValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ABIParamValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ABIParamValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ABIParamValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ABIParamValidationError) ErrorName() string { return "ABIParamValidationError" }

// Error satisfies the builtin error interface
func (e ABIParamValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sABIParam.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ABIParamValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ABIParamValidationError{}

// Validate checks the field values on ABIBaseValue with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ABIBaseValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ABIBaseValue with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ABIBaseValueMultiError, or
// nil if none found.
func (m *ABIBaseValue) ValidateAll() error {
	return m.validate(true)
}

func (m *ABIBaseValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.BaseValue.(type) {
	case *ABIBaseValue_UintX:
		if v == nil {
			err := ABIBaseValueValidationError{
				field:  "BaseValue",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for UintX
	case *ABIBaseValue_Address:
		if v == nil {
			err := ABIBaseValueValidationError{
				field:  "BaseValue",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Address
	case *ABIBaseValue_BytesX:
		if v == nil {
			err := ABIBaseValueValidationError{
				field:  "BaseValue",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for BytesX
	case *ABIBaseValue_StringX:
		if v == nil {
			err := ABIBaseValueValidationError{
				field:  "BaseValue",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for StringX
	case *ABIBaseValue_Hash:
		if v == nil {
			err := ABIBaseValueValidationError{
				field:  "BaseValue",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Hash
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ABIBaseValueMultiError(errors)
	}

	return nil
}

// ABIBaseValueMultiError is an error wrapping multiple validation errors
// returned by ABIBaseValue.ValidateAll() if the designated constraints aren't met.
type ABIBaseValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ABIBaseValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ABIBaseValueMultiError) AllErrors() []error { return m }

// ABIBaseValueValidationError is the validation error returned by
// ABIBaseValue.Validate if the designated constraints aren't met.
type ABIBaseValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ABIBaseValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ABIBaseValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ABIBaseValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ABIBaseValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ABIBaseValueValidationError) ErrorName() string { return "ABIBaseValueValidationError" }

// Error satisfies the builtin error interface
func (e ABIBaseValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sABIBaseValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ABIBaseValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ABIBaseValueValidationError{}

// Validate checks the field values on ABIArrayBaseValue with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ABIArrayBaseValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ABIArrayBaseValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ABIArrayBaseValueMultiError, or nil if none found.
func (m *ABIArrayBaseValue) ValidateAll() error {
	return m.validate(true)
}

func (m *ABIArrayBaseValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ABIArrayBaseValueValidationError{
						field:  fmt.Sprintf("Values[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ABIArrayBaseValueValidationError{
						field:  fmt.Sprintf("Values[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ABIArrayBaseValueValidationError{
					field:  fmt.Sprintf("Values[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ABIArrayBaseValueMultiError(errors)
	}

	return nil
}

// ABIArrayBaseValueMultiError is an error wrapping multiple validation errors
// returned by ABIArrayBaseValue.ValidateAll() if the designated constraints
// aren't met.
type ABIArrayBaseValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ABIArrayBaseValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ABIArrayBaseValueMultiError) AllErrors() []error { return m }

// ABIArrayBaseValueValidationError is the validation error returned by
// ABIArrayBaseValue.Validate if the designated constraints aren't met.
type ABIArrayBaseValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ABIArrayBaseValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ABIArrayBaseValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ABIArrayBaseValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ABIArrayBaseValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ABIArrayBaseValueValidationError) ErrorName() string {
	return "ABIArrayBaseValueValidationError"
}

// Error satisfies the builtin error interface
func (e ABIArrayBaseValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sABIArrayBaseValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ABIArrayBaseValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ABIArrayBaseValueValidationError{}

// Validate checks the field values on ABIStructValue with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ABIStructValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ABIStructValue with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ABIStructValueMultiError,
// or nil if none found.
func (m *ABIStructValue) ValidateAll() error {
	return m.validate(true)
}

func (m *ABIStructValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetStructValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ABIStructValueValidationError{
						field:  fmt.Sprintf("StructValue[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ABIStructValueValidationError{
						field:  fmt.Sprintf("StructValue[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ABIStructValueValidationError{
					field:  fmt.Sprintf("StructValue[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ABIStructValueMultiError(errors)
	}

	return nil
}

// ABIStructValueMultiError is an error wrapping multiple validation errors
// returned by ABIStructValue.ValidateAll() if the designated constraints
// aren't met.
type ABIStructValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ABIStructValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ABIStructValueMultiError) AllErrors() []error { return m }

// ABIStructValueValidationError is the validation error returned by
// ABIStructValue.Validate if the designated constraints aren't met.
type ABIStructValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ABIStructValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ABIStructValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ABIStructValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ABIStructValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ABIStructValueValidationError) ErrorName() string { return "ABIStructValueValidationError" }

// Error satisfies the builtin error interface
func (e ABIStructValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sABIStructValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ABIStructValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ABIStructValueValidationError{}

// Validate checks the field values on ABIArrayStructValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ABIArrayStructValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ABIArrayStructValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ABIArrayStructValueMultiError, or nil if none found.
func (m *ABIArrayStructValue) ValidateAll() error {
	return m.validate(true)
}

func (m *ABIArrayStructValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetStructValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ABIArrayStructValueValidationError{
						field:  fmt.Sprintf("StructValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ABIArrayStructValueValidationError{
						field:  fmt.Sprintf("StructValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ABIArrayStructValueValidationError{
					field:  fmt.Sprintf("StructValues[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ABIArrayStructValueMultiError(errors)
	}

	return nil
}

// ABIArrayStructValueMultiError is an error wrapping multiple validation
// errors returned by ABIArrayStructValue.ValidateAll() if the designated
// constraints aren't met.
type ABIArrayStructValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ABIArrayStructValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ABIArrayStructValueMultiError) AllErrors() []error { return m }

// ABIArrayStructValueValidationError is the validation error returned by
// ABIArrayStructValue.Validate if the designated constraints aren't met.
type ABIArrayStructValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ABIArrayStructValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ABIArrayStructValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ABIArrayStructValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ABIArrayStructValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ABIArrayStructValueValidationError) ErrorName() string {
	return "ABIArrayStructValueValidationError"
}

// Error satisfies the builtin error interface
func (e ABIArrayStructValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sABIArrayStructValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ABIArrayStructValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ABIArrayStructValueValidationError{}

// Validate checks the field values on ABIBytesDecodeValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ABIBytesDecodeValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ABIBytesDecodeValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ABIBytesDecodeValueMultiError, or nil if none found.
func (m *ABIBytesDecodeValue) ValidateAll() error {
	return m.validate(true)
}

func (m *ABIBytesDecodeValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BytesX

	switch v := m.DecodeValue.(type) {
	case *ABIBytesDecodeValue_Function:
		if v == nil {
			err := ABIBytesDecodeValueValidationError{
				field:  "DecodeValue",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFunction()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ABIBytesDecodeValueValidationError{
						field:  "Function",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ABIBytesDecodeValueValidationError{
						field:  "Function",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFunction()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ABIBytesDecodeValueValidationError{
					field:  "Function",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ABIBytesDecodeValue_Param:
		if v == nil {
			err := ABIBytesDecodeValueValidationError{
				field:  "DecodeValue",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetParam()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ABIBytesDecodeValueValidationError{
						field:  "Param",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ABIBytesDecodeValueValidationError{
						field:  "Param",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetParam()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ABIBytesDecodeValueValidationError{
					field:  "Param",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ABIBytesDecodeValueMultiError(errors)
	}

	return nil
}

// ABIBytesDecodeValueMultiError is an error wrapping multiple validation
// errors returned by ABIBytesDecodeValue.ValidateAll() if the designated
// constraints aren't met.
type ABIBytesDecodeValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ABIBytesDecodeValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ABIBytesDecodeValueMultiError) AllErrors() []error { return m }

// ABIBytesDecodeValueValidationError is the validation error returned by
// ABIBytesDecodeValue.Validate if the designated constraints aren't met.
type ABIBytesDecodeValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ABIBytesDecodeValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ABIBytesDecodeValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ABIBytesDecodeValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ABIBytesDecodeValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ABIBytesDecodeValueValidationError) ErrorName() string {
	return "ABIBytesDecodeValueValidationError"
}

// Error satisfies the builtin error interface
func (e ABIBytesDecodeValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sABIBytesDecodeValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ABIBytesDecodeValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ABIBytesDecodeValueValidationError{}

// Validate checks the field values on PageInfoReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PageInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PageInfoReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PageInfoReqMultiError, or
// nil if none found.
func (m *PageInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *PageInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPage() < 0 {
		err := PageInfoReqValidationError{
			field:  "Page",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPerPage() <= 0 {
		err := PageInfoReqValidationError{
			field:  "PerPage",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for LastID

	// no validation rules for NextID

	if len(errors) > 0 {
		return PageInfoReqMultiError(errors)
	}

	return nil
}

// PageInfoReqMultiError is an error wrapping multiple validation errors
// returned by PageInfoReq.ValidateAll() if the designated constraints aren't met.
type PageInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PageInfoReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PageInfoReqMultiError) AllErrors() []error { return m }

// PageInfoReqValidationError is the validation error returned by
// PageInfoReq.Validate if the designated constraints aren't met.
type PageInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PageInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PageInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PageInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PageInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PageInfoReqValidationError) ErrorName() string { return "PageInfoReqValidationError" }

// Error satisfies the builtin error interface
func (e PageInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPageInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PageInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PageInfoReqValidationError{}
